# -*- coding: utf-8 -*-
"""exercicio_1_A_AyrtonCossuol.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1371vuzaujYWTWtZuTALqLbjSjNcx6Zda
"""

#Exercicio - 1, A
import numpy as np
import matplotlib.pyplot as plt
from numpy import pi
from numpy.fft import fft, ifft, fftfreq, fftshift

def cria_sinal(n):
  return np.cos(((6*pi/13)*n)+(pi/6))

def calculo_DTFS(x):
  return fft(x)/len(x)

def shift_sinal(X, w):
  return fftshift(X), fftshift(w)

def retorna_sinal(X, x):
  return np.real(ifft(X)*len(x))

def main():
  # criando o vetor de amostra com tamanho nper  periodos do sinal
  # periodo do sinal e quantidade de periodos em x[n]
  N, nper = 13, 3
  n = np.arange(0, nper*N)

  #criando o vetor do sinal x[n] = cos(((6*pi/13)*n)+(pi/6))
  x = cria_sinal(n)

  # calculando a DTFS
  X = calculo_DTFS(x)

  #criando o vetor de frequencia
  w = fftfreq(len(n), d=1/N)

  # Os indices de frequencia são mudados de 0 a N-1 para -N/2 + 1 a N/2
  # posicionando a freq. zero no meio do gráfico
  Xd, w = shift_sinal(X, w)

  # calculando o modulo - magnitude do espectro e calculando a fase do espectro
  ModX, phasX = np.abs(Xd), np.angle(Xd)

  # devido a erros de arredondamentos numericos da fft devemos filtrar os sinais muito pequenos!
  phasX[ModX < 0.00001] = 0 #  cuidado com isso aqui, isso depende do previo conhecimento do sinal

  plt.figure(figsize=(12, 8))
  plt.stem(w, ModX, use_line_collection=True)
  plt.title('|X[n]|')
  plt.ylabel('Amplitude')
  plt.xlabel('k')
  plt.show()

  plt.figure(figsize=(12, 8))
  plt.stem(w,phasX, use_line_collection=True)
  plt.title('Angulo (X[n])')
  plt.ylabel('Amplitude')
  plt.xlabel('k')
  plt.show()

if __name__ == "__main__":
  main()