# -*- coding: utf-8 -*-
"""exercicio_2_C_AyrtonCossuol.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1371vuzaujYWTWtZuTALqLbjSjNcx6Zda
"""

#Atividade 2 - C 
import numpy as np
import matplotlib.pyplot as plt
from numpy import pi
from numpy.fft import fft, ifft, fftfreq, fftshift

def sinal_modulo(n):
  modulo = []

  for i in range(len(n)):
    if i == 3 or i == 4:
      modulo.append(1)
    else:
      modulo.append(0)

  return modulo

def sinal_fase(n):
  fase = []

  for i in range(len(n)):
    if i == 3:
      fase.append(-1)
    elif i == 4:
      fase.append(1)
    else:
      fase.append(0)

  return fase

def cria_sinal(modX, phasX):
  X = []

  for i in range(len(modX)):
    ret_x = modX[i] * np.cos(phasX[i]*(np.pi/2))
    ret_y = modX[i] * np.sin(phasX[i]*(np.pi/2))
    
    retangular = complex(ret_x, ret_y)
    
    X.append(retangular)
  return X

def main():
  # periodo do sinal
  N = 7       
  # criando o vetor de tempo
  n = np.arange(0, N)

  # criando o vetor de frequencia
  w = fftfreq(len(n), d=1/N)

  # calculando o modulo - magnitude do espectro
  ModX = sinal_modulo(n) 

  # # calculando a fase do espectro
  phasX = sinal_fase(n) 

  # # calculando sinal X
  X = cria_sinal(ModX, phasX)

  # retornando o sinal ao dominio do tempo e ignorando os erros de 
  #arredondamento do fft e ifft
  xr = np.real(ifft(X) * len(n))

  plt.figure(figsize=(12, 8))
  plt.stem(w, xr, use_line_collection=True)
  plt.title('xr[n]')
  plt.ylabel('Amplitude')
  plt.xlabel('Amostra')
  plt.show()

if __name__ == "__main__":
  main()

