# -*- coding: utf-8 -*-
"""exercicio_2_A_AyrtonCossuol.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LOftT3KOxUJZ2Ahf6XJNiQLxUcul39ZJ
"""

# -*- coding: utf-8 -*-
"""exercicio_2_A_AyrtonCossuol.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1LOftT3KOxUJZ2Ahf6XJNiQLxUcul39ZJ
"""

# Exercicio - 2 - A
import numpy as np
import matplotlib.pyplot as plt
from numpy.fft import fft, ifft, fftfreq, fftshift

def degrau(t, to):
    degrau = np.arange(t[0], (t[-1] + t[1]-t[0]), t[1]-t[0])
    
    for i in range(len(degrau)):
        if degrau[i] >= to:
            degrau[i] = 1
        else:
            degrau[i] = 0
    
    return degrau

def main():
  # Criando a respectiva frequencia e tempo de cada alternativa
  w_amp_a = 300  
  tam_a = (2 * np.pi) / w_amp_a    
  t1_a = 2        
  t_a = t1_a / 0.0001
  ta = np.arange(0, t_a + tam_a, tam_a)
  
  w_amp_b = w_amp_a * (5/6)  
  tam_b = (2 * np.pi) / w_amp_b    
  t1_b = t1_a / 2        
  t_b = t1_b / 0.0001
  tb = np.arange(0, t_b + tam_b, tam_b)
  
  w_amp_c = w_amp_a * (1/3)  
  tam_c = (2 * np.pi) / w_amp_c
  t1_c = t1_a * (7/40)    
  t_c = t1_c / 0.0001
  tc = np.arange(0, t_c + tam_c, tam_c)

  # Criando os sinais passados pela questão
  xa = degrau(ta, 0) - degrau(ta, 2)
  xb = degrau(tb, 0) - degrau(tb, 1)
  xc = degrau(tc, 0) - degrau(tc, 0.35)

  # N - tamanho da DTFS
  N = np.power(2, 12)

  # Calculando a FT
  Xa, Xb, Xc = ((tam_a * N) * fft(xa, N) / N), ((tam_b * N) * fft(xb, N) / N), ((tam_c * N) * fft(xc, N) / N)

  # Criando os vetores de frequencia
  wa, wb, wc = (fftfreq(len(Xa), d=(tam_a)) * (2 * np.pi)), (fftfreq(len(Xb), d=(tam_b)) * (2 * np.pi)), (fftfreq(len(Xc), d=(tam_c)) * (2 * np.pi))

  # Os indices de frequencia são mudados de 0 a N-1 para -N/2 + 1 a N/2
  # posicionando a freq. zero no meio do gráfico
  wda, Xda = fftshift(wa), fftshift(Xa)
  wdb, Xdb = fftshift(wb), fftshift(Xb)
  wdc, Xdc = fftshift(wc), fftshift(Xc)

  # Calculando o modulo e fase
  ModXa, phasXa = np.abs(Xda), np.angle(Xda)
  ModXb, phasXb = np.abs(Xdb), np.angle(Xdb)
  ModXc, phasXc = np.abs(Xdc), np.angle(Xdc)

  fig, ax = plt.subplots(3, 1)
  # Representação dos sinais no tempo
  ax[0].plot(ta, xa, 'magenta', linewidth=1, label="")
  ax[0].set_ylabel("Amplitude")
  ax[0].set_xlabel("t_a")
  ax[0].set_xlim(-10, 10)
  ax[0].set_title('xa(t_a)')
  ax[0].grid(True)

  ax[0].plot(tb, xb, 'yellow', linewidth=1, label="")
  ax[0].set_ylabel("Amplitude")
  ax[0].set_xlabel("t_b")
  ax[0].set_xlim(-10, 10)
  ax[0].set_title('xb(t_b)')
  ax[0].grid(True)

  ax[0].plot(tc, xc, 'b-', linewidth=1, label="")
  ax[0].set_ylabel("Amplitude")
  ax[0].set_xlabel("t_c")
  ax[0].set_xlim(-10, 10)
  ax[0].set_title('xc(t_c)')
  ax[0].grid(True)

  # Representação dos modulos das ft
  ax[1].plot(wda, ModXa, 'magenta', linewidth=1, label="")
  ax[1].set_ylabel("Amplitude")
  ax[1].set_xlabel("rad/s")
  ax[1].set_xlim(-50, 50)
  ax[1].set_title('|Xa(e^jw)|')
  ax[1].grid(True)

  ax[1].plot(wdb, ModXb, 'yellow', linewidth=1, label="")
  ax[1].set_ylabel("Amplitude")
  ax[1].set_xlabel("rad/s")
  ax[1].set_xlim(-50, 50)
  ax[1].set_title('|Xb(e^jw)|')
  ax[1].grid(True)

  ax[1].plot(wdc, ModXc, 'b-', linewidth=1, label="")
  ax[1].set_ylabel("Amplitude")
  ax[1].set_xlabel("rad/s")
  ax[1].set_xlim(-50, 50)
  ax[1].set_title('|Xc(e^jw)|')
  ax[1].grid(True)

  # Representação dos angulos das ft
  ax[2].stem(wda, phasXa, 'magenta', label="", use_line_collection=True)
  ax[2].set_ylabel("Amplitude")
  ax[2].set_xlabel("rad/s")
  ax[2].set_xlim(-5, 5)
  ax[2].set_title('angle(Xa(e^jw))')
  ax[2].grid(True)

  ax[2].stem(wdb, phasXb, 'yellow', label="", use_line_collection=True)
  ax[2].set_ylabel("Amplitude")
  ax[2].set_xlabel("rad/s")
  ax[2].set_xlim(-5, 5)
  ax[2].set_title('angle(Xb(e^jw))')
  ax[2].grid(True)

  ax[2].stem(wdc, phasXc, 'b-', label="", use_line_collection=True)
  ax[2].set_ylabel("Amplitude")
  ax[2].set_xlabel("rad/s")
  ax[2].set_xlim(-5, 5)
  ax[2].set_title('angle(Xc(e^jw))')
  ax[2].grid(True)

  plt.tight_layout()
  plt.show()

if __name__ == '__main__':
  main()

